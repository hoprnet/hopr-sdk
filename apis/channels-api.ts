/* tslint:disable */
/* eslint-disable */
/**
 * HOPRd Rest API v2
 * This Rest API enables developers to interact with a hoprd node programatically.
 *
 * OpenAPI spec version: 2.0.0
 * Contact: tech@hoprnet.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { Channel } from '../models';
import { ChannelsBody } from '../models';
import { FundmultiBody } from '../models';
import { HoprAddress } from '../models';
import { InlineResponse20011 } from '../models';
import { InlineResponse2005 } from '../models';
import { InlineResponse2011 } from '../models';
import { InlineResponse2012 } from '../models';
import { InlineResponse403 } from '../models';
import { InlineResponse4031 } from '../models';
import { InlineResponse409 } from '../models';
import { InlineResponse422 } from '../models';
import { RequestStatus } from '../models';
import { Ticket } from '../models';
/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Close a opened channel between this node and other node. Once you've initiated channel closure, you have to wait for a specified closure time, it will show you a closure initiation message with cool-off time you need to wait.   Then you will need to send the same command again to finalize closure. This is a cool down period to give the other party in the channel sufficient time to redeem their tickets.
         * @param {string} peerid 
         * @param {string} direction Specify which channel should be fetched, incoming or outgoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsCloseChannel: async (peerid: string, direction: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'peerid' is not null or undefined
            if (peerid === null || peerid === undefined) {
                throw new RequiredError('peerid','Required parameter peerid was null or undefined when calling channelsCloseChannel.');
            }
            // verify required parameter 'direction' is not null or undefined
            if (direction === null || direction === undefined) {
                throw new RequiredError('direction','Required parameter direction was null or undefined when calling channelsCloseChannel.');
            }
            const localVarPath = `/channels/{peerid}/{direction}/`
                .replace(`{${"peerid"}}`, encodeURIComponent(String(peerid)))
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication keyScheme required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-auth-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            // authentication passwordScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fund one or two payment channels between this node and the counter party provided.
         * @param {FundmultiBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsFundChannels: async (body?: FundmultiBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundmulti/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication keyScheme required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-auth-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            // authentication passwordScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the channel between this node and provided peerId.
         * @param {HoprAddress} peerid Counterparty peerId assigned to the channel you want to fetch.
         * @param {string} direction Specify which channel should be fetched, incoming or outgoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsGetChannel: async (peerid: HoprAddress, direction: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'peerid' is not null or undefined
            if (peerid === null || peerid === undefined) {
                throw new RequiredError('peerid','Required parameter peerid was null or undefined when calling channelsGetChannel.');
            }
            // verify required parameter 'direction' is not null or undefined
            if (direction === null || direction === undefined) {
                throw new RequiredError('direction','Required parameter direction was null or undefined when calling channelsGetChannel.');
            }
            const localVarPath = `/channels/{peerid}/{direction}/`
                .replace(`{${"peerid"}}`, encodeURIComponent(String(peerid)))
                .replace(`{${"direction"}}`, encodeURIComponent(String(direction)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication keyScheme required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-auth-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            // authentication passwordScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all active channels between this node and other nodes on the Hopr network. By default response will contain all incomming and outgoing channels that are either open, waiting to be opened, or waiting to be closed. If you also want to receive past channels that were closed, you can pass `includingClosed` in the request url query.
         * @param {string} [includingClosed] When includingClosed is passed the response will include closed channels which are ommited by default.
         * @param {string} [fullTopology] Get the full payment channel graph indexed by the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsGetChannels: async (includingClosed?: string, fullTopology?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication keyScheme required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-auth-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            // authentication passwordScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includingClosed !== undefined) {
                localVarQueryParameter['includingClosed'] = includingClosed;
            }

            if (fullTopology !== undefined) {
                localVarQueryParameter['fullTopology'] = fullTopology;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tickets earned by relaying data packets by your node for the particular channel.
         * @param {string} peerid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsGetTickets: async (peerid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'peerid' is not null or undefined
            if (peerid === null || peerid === undefined) {
                throw new RequiredError('peerid','Required parameter peerid was null or undefined when calling channelsGetTickets.');
            }
            const localVarPath = `/channels/{peerid}/tickets`
                .replace(`{${"peerid"}}`, encodeURIComponent(String(peerid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication keyScheme required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-auth-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            // authentication passwordScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Opens a payment channel between this node and the counter party provided. This channel can be used to send messages between two nodes using other nodes on the network to relay the messages. Each message will deduce its cost from the funded amount to pay other nodes for relaying your messages. Opening a channel can take a little bit of time, because it requires some block confirmations on the blockchain.
         * @param {ChannelsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsOpenChannel: async (body?: ChannelsBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication keyScheme required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-auth-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            // authentication passwordScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Redeems your tickets for this channel. Redeeming will change your tickets into Hopr tokens if they are winning ones. You can check how much tickets given channel has by calling /channels/{peerid}/tickets endpoint. Do this before channel is closed as neglected tickets are no longer valid for redeeming.
         * @param {string} peerid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsRedeemTickets: async (peerid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'peerid' is not null or undefined
            if (peerid === null || peerid === undefined) {
                throw new RequiredError('peerid','Required parameter peerid was null or undefined when calling channelsRedeemTickets.');
            }
            const localVarPath = `/channels/{peerid}/tickets/redeem`
                .replace(`{${"peerid"}}`, encodeURIComponent(String(peerid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication keyScheme required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-auth-token")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-auth-token"] = localVarApiKeyValue;
            }

            // authentication passwordScheme required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Close a opened channel between this node and other node. Once you've initiated channel closure, you have to wait for a specified closure time, it will show you a closure initiation message with cool-off time you need to wait.   Then you will need to send the same command again to finalize closure. This is a cool down period to give the other party in the channel sufficient time to redeem their tickets.
         * @param {string} peerid 
         * @param {string} direction Specify which channel should be fetched, incoming or outgoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsCloseChannel(peerid: string, direction: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20011>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelsCloseChannel(peerid, direction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fund one or two payment channels between this node and the counter party provided.
         * @param {FundmultiBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsFundChannels(body?: FundmultiBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2011>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelsFundChannels(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns information about the channel between this node and provided peerId.
         * @param {HoprAddress} peerid Counterparty peerId assigned to the channel you want to fetch.
         * @param {string} direction Specify which channel should be fetched, incoming or outgoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsGetChannel(peerid: HoprAddress, direction: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Channel>>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelsGetChannel(peerid, direction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all active channels between this node and other nodes on the Hopr network. By default response will contain all incomming and outgoing channels that are either open, waiting to be opened, or waiting to be closed. If you also want to receive past channels that were closed, you can pass `includingClosed` in the request url query.
         * @param {string} [includingClosed] When includingClosed is passed the response will include closed channels which are ommited by default.
         * @param {string} [fullTopology] Get the full payment channel graph indexed by the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsGetChannels(includingClosed?: string, fullTopology?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelsGetChannels(includingClosed, fullTopology, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get tickets earned by relaying data packets by your node for the particular channel.
         * @param {string} peerid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsGetTickets(peerid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Ticket>>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelsGetTickets(peerid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Opens a payment channel between this node and the counter party provided. This channel can be used to send messages between two nodes using other nodes on the network to relay the messages. Each message will deduce its cost from the funded amount to pay other nodes for relaying your messages. Opening a channel can take a little bit of time, because it requires some block confirmations on the blockchain.
         * @param {ChannelsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsOpenChannel(body?: ChannelsBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2012>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelsOpenChannel(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Redeems your tickets for this channel. Redeeming will change your tickets into Hopr tokens if they are winning ones. You can check how much tickets given channel has by calling /channels/{peerid}/tickets endpoint. Do this before channel is closed as neglected tickets are no longer valid for redeeming.
         * @param {string} peerid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsRedeemTickets(peerid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelsRedeemTickets(peerid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Close a opened channel between this node and other node. Once you've initiated channel closure, you have to wait for a specified closure time, it will show you a closure initiation message with cool-off time you need to wait.   Then you will need to send the same command again to finalize closure. This is a cool down period to give the other party in the channel sufficient time to redeem their tickets.
         * @param {string} peerid 
         * @param {string} direction Specify which channel should be fetched, incoming or outgoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsCloseChannel(peerid: string, direction: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20011>> {
            return ChannelsApiFp(configuration).channelsCloseChannel(peerid, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Fund one or two payment channels between this node and the counter party provided.
         * @param {FundmultiBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsFundChannels(body?: FundmultiBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2011>> {
            return ChannelsApiFp(configuration).channelsFundChannels(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the channel between this node and provided peerId.
         * @param {HoprAddress} peerid Counterparty peerId assigned to the channel you want to fetch.
         * @param {string} direction Specify which channel should be fetched, incoming or outgoing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsGetChannel(peerid: HoprAddress, direction: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Channel>>> {
            return ChannelsApiFp(configuration).channelsGetChannel(peerid, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all active channels between this node and other nodes on the Hopr network. By default response will contain all incomming and outgoing channels that are either open, waiting to be opened, or waiting to be closed. If you also want to receive past channels that were closed, you can pass `includingClosed` in the request url query.
         * @param {string} [includingClosed] When includingClosed is passed the response will include closed channels which are ommited by default.
         * @param {string} [fullTopology] Get the full payment channel graph indexed by the node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsGetChannels(includingClosed?: string, fullTopology?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return ChannelsApiFp(configuration).channelsGetChannels(includingClosed, fullTopology, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tickets earned by relaying data packets by your node for the particular channel.
         * @param {string} peerid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsGetTickets(peerid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Ticket>>> {
            return ChannelsApiFp(configuration).channelsGetTickets(peerid, options).then((request) => request(axios, basePath));
        },
        /**
         * Opens a payment channel between this node and the counter party provided. This channel can be used to send messages between two nodes using other nodes on the network to relay the messages. Each message will deduce its cost from the funded amount to pay other nodes for relaying your messages. Opening a channel can take a little bit of time, because it requires some block confirmations on the blockchain.
         * @param {ChannelsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsOpenChannel(body?: ChannelsBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2012>> {
            return ChannelsApiFp(configuration).channelsOpenChannel(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Redeems your tickets for this channel. Redeeming will change your tickets into Hopr tokens if they are winning ones. You can check how much tickets given channel has by calling /channels/{peerid}/tickets endpoint. Do this before channel is closed as neglected tickets are no longer valid for redeeming.
         * @param {string} peerid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelsRedeemTickets(peerid: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return ChannelsApiFp(configuration).channelsRedeemTickets(peerid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
    /**
     * Close a opened channel between this node and other node. Once you've initiated channel closure, you have to wait for a specified closure time, it will show you a closure initiation message with cool-off time you need to wait.   Then you will need to send the same command again to finalize closure. This is a cool down period to give the other party in the channel sufficient time to redeem their tickets.
     * @param {string} peerid 
     * @param {string} direction Specify which channel should be fetched, incoming or outgoing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public async channelsCloseChannel(peerid: string, direction: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20011>> {
        return ChannelsApiFp(this.configuration).channelsCloseChannel(peerid, direction, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fund one or two payment channels between this node and the counter party provided.
     * @param {FundmultiBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public async channelsFundChannels(body?: FundmultiBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2011>> {
        return ChannelsApiFp(this.configuration).channelsFundChannels(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns information about the channel between this node and provided peerId.
     * @param {HoprAddress} peerid Counterparty peerId assigned to the channel you want to fetch.
     * @param {string} direction Specify which channel should be fetched, incoming or outgoing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public async channelsGetChannel(peerid: HoprAddress, direction: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Channel>>> {
        return ChannelsApiFp(this.configuration).channelsGetChannel(peerid, direction, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all active channels between this node and other nodes on the Hopr network. By default response will contain all incomming and outgoing channels that are either open, waiting to be opened, or waiting to be closed. If you also want to receive past channels that were closed, you can pass `includingClosed` in the request url query.
     * @param {string} [includingClosed] When includingClosed is passed the response will include closed channels which are ommited by default.
     * @param {string} [fullTopology] Get the full payment channel graph indexed by the node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public async channelsGetChannels(includingClosed?: string, fullTopology?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return ChannelsApiFp(this.configuration).channelsGetChannels(includingClosed, fullTopology, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get tickets earned by relaying data packets by your node for the particular channel.
     * @param {string} peerid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public async channelsGetTickets(peerid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Ticket>>> {
        return ChannelsApiFp(this.configuration).channelsGetTickets(peerid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Opens a payment channel between this node and the counter party provided. This channel can be used to send messages between two nodes using other nodes on the network to relay the messages. Each message will deduce its cost from the funded amount to pay other nodes for relaying your messages. Opening a channel can take a little bit of time, because it requires some block confirmations on the blockchain.
     * @param {ChannelsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public async channelsOpenChannel(body?: ChannelsBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2012>> {
        return ChannelsApiFp(this.configuration).channelsOpenChannel(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Redeems your tickets for this channel. Redeeming will change your tickets into Hopr tokens if they are winning ones. You can check how much tickets given channel has by calling /channels/{peerid}/tickets endpoint. Do this before channel is closed as neglected tickets are no longer valid for redeeming.
     * @param {string} peerid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public async channelsRedeemTickets(peerid: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return ChannelsApiFp(this.configuration).channelsRedeemTickets(peerid, options).then((request) => request(this.axios, this.basePath));
    }
}
